# set.seed(1)
library(quantreg)
library(conquer)
tau.grid = seq(from=.01,to=.99, by=.02)
# freely and then choose v00 restricted with the restriction that
# v10 + v01 - v00 is non-decreasing and has its range contained
# in the unit interval [0,1]. If the functions are chosen
# to be differentiable quantile functions, it is sufficient
# then to choose v00 so that
# v10' + v01' \ge v00'
# or, equivalently, log(v10' + v01')-log(v00')\ge0
# The function qdbplot below allows us to investigate
# if this inequality holds when v00, v10 and v01
# are chosen to be Beta quantile functions:
qdbplot = function(a10,b10,a01,b01,a00,b00){
tau = seq(from=0.00001,to=.99999,by=.00001)
v00prime = 1/dbeta(qbeta(tau,a00,b00),a00,b00)
v10prime = 1/dbeta(qbeta(tau,a10,b10),a10,b10)
v01prime = 1/dbeta(qbeta(tau,a01,b01),a01,b01)
plot(tau, log(v10prime+v01prime)-log(v00prime), type = 'l'); abline(h=0, col='red')
}
# A function for visualizing the Beta densities:
dbplot = function(a,b){
tau = seq(from=0,to=1,by=.01)
plot(tau, dbeta(tau,a,b))
}
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 3; a01 = 5; b01 = 1; a00 = 3; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 3; a01 = 6; b01 = 1; a00 = 3; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 3; a01 = 6; b01 = 5; a00 = 3; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 3; a01 = 1; b01 = 5; a00 = 3; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 3; a01 = 6; b01 = 1; a00 = 3; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 3; a01 = 5; b01 = 1; a00 = 3; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 3; a01 = 4; b01 = 1; a00 = 3; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Conditional quantile function of Y[t] given Y[t-1] = 1 and X[t-1]=0
v10 = function (tau) qbeta(tau, a10,b10)
# Conditional density of Y[t] given Y[t-1] = 1 and X[t-1]=0
dbplot(a10,b10)
# Conditional quantile function of Y[t] given Y[t-1] = 0 and X[t-1]=1
v01 = function(tau) qbeta(tau,a01,b01)
# Conditional density of Y[t] given Y[t-1] = 0 and X[t-1]=1
dbplot(a01,b01)
# Conditional quantile function of Y[t] given Y[t-1] = 0 and X[t-1]=0
v00 = function(tau) qbeta(tau,a00,b00)
# Conditional density of Y[t] given Y[t-1] = 0 and X[t-1]=0
dbplot(a00,b00)
# Conditional quantile function of Y[t] given Y[t-1] = 1 and X[t-1]=1
v11 = function(tau) v10(tau) + v01(tau) - v00(tau)
# Plot of v11 (must be nondecreasing and with range contained in [0,1])
plot(tau.grid, v11(tau.grid))
# Conditional density of Y[t] given Y[t-1] = 1 and X[t-1]=1
q11 = function(tau) {
1/dbeta(v10(tau),a10,b10) + 1/dbeta(v01(tau),a01,b01) - 1/dbeta(v00(tau),a00,b00)
}
plot(v11(tau.grid), 1/q11(tau.grid), xlim=c(0,1))
qdbplot(a10,b10, a01,b01, a00,b00)
# Conditional density of Y[t] given Y[t-1] = 1 and X[t-1]=0
dbplot(a10,b10)
# Conditional quantile function of Y[t] given Y[t-1] = 1 and X[t-1]=0
v10 = function (tau) qbeta(tau, a10,b10)
# Conditional density of Y[t] given Y[t-1] = 1 and X[t-1]=0
dbplot(a10,b10)
# Conditional quantile function of Y[t] given Y[t-1] = 0 and X[t-1]=1
v01 = function(tau) qbeta(tau,a01,b01)
# Conditional density of Y[t] given Y[t-1] = 0 and X[t-1]=1
dbplot(a01,b01)
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 3; a01 = 1; b01 = 1; a00 = 3; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 3; a01 = 4; b01 = 1; a00 = 3; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Conditional quantile function of Y[t] given Y[t-1] = 1 and Z[t-1]=0
v10 = function (tau) qbeta(tau, a10,b10)
# Conditional density of Y[t] given Y[t-1] = 1 and Z[t-1]=0
dbplot(a10,b10)
# Conditional quantile function of Y[t] given Y[t-1] = 0 and Z[t-1]=1
v01 = function(tau) qbeta(tau,a01,b01)
# Conditional density of Y[t] given Y[t-1] = 0 and Z[t-1]=1
dbplot(a01,b01)
# Conditional quantile function of Y[t] given Y[t-1] = 0 and Z[t-1]=0
v00 = function(tau) qbeta(tau,a00,b00)
# Conditional density of Y[t] given Y[t-1] = 0 and Z[t-1]=0
dbplot(a00,b00)
# Conditional quantile function of Y[t] given Y[t-1] = 1 and Z[t-1]=1
v11 = function(tau) v10(tau) + v01(tau) - v00(tau)
# Plot of v11 (must be nondecreasing and with range contained in [0,1])
plot(tau.grid, v11(tau.grid))
# Conditional density of Y[t] given Y[t-1] = 1 and Z[t-1]=1
q11 = function(tau) {
1/dbeta(v10(tau),a10,b10) + 1/dbeta(v01(tau),a01,b01) - 1/dbeta(v00(tau),a00,b00)
}
plot(v11(tau.grid), 1/q11(tau.grid), xlim=c(0,1))
# Functional parameters for the quantile regression equation
alpha0 = v00
alpha1 = function(tau) v10(tau) - v00(tau)
theta1 = function(tau) v01(tau) - v00(tau)
# Quantile function of Y given ‚Ñ±[t-1]
Q = function(tau,Y.current,Z.current){
alpha0(tau) + alpha1(tau)*Y.current + theta1(tau)*Z.current
}
# Arbitrary starting point (Y0,Z0)
Y0 = runif(1)
Z0 = runif(1)
Y = Z = numeric()
Z.current = Z0
Y.current = Y0
T = 10001
for (t in 1:T){
# Simulates Y[t] given ‚Ñ±[t-1] using the Fundamental Theorem of Simulation
Y[t] = Q(runif(1), Y.current, Z.current)
Z[t] = Q(runif(1), Z.current, Y.current)
# Q(runif(1), Z.current, Y.current)
# Z[t] = runif(1,max(Y[t]-.01,0),min(Y[t]+.01,1))
Z.current = Z[t]
Y.current = Y[t]
}
Y = Y[-1]
Z = Z[-1]
T = length(Y)
# This code simulates a sample path of size T from a simple QARDL(1,1) model:
# Q(ùúè| ‚Ñ±[t-1]) = Œ±‚ÇÄ(ùúè) + Œ±‚ÇÅ(ùúè)*Y[t-1] + Œ∏‚ÇÅ(ùúè)*Z[t-1]
# set.seed(1)
library(quantreg)
library(conquer)
tau.grid = seq(from=.01,to=.99, by=.02)
# Value of the conditional quantile function at three
# vertices of the unit square (v10, v01, v00 and v11)
# Since v11 = v10 + v01 - v00 we can choose, say, v10 and v01
# freely and then choose v00 restricted with the restriction that
# v10 + v01 - v00 is non-decreasing and has its range contained
# in the unit interval [0,1]. If the functions are chosen
# to be differentiable quantile functions, it is sufficient
# then to choose v00 so that
# v10' + v01' \ge v00'
# or, equivalently, log(v10' + v01')-log(v00')\ge0
# The function qdbplot below allows us to investigate
# if this inequality holds when v00, v10 and v01
# are chosen to be Beta quantile functions:
qdbplot = function(a10,b10,a01,b01,a00,b00){
tau = seq(from=0.00001,to=.99999,by=.00001)
v00prime = 1/dbeta(qbeta(tau,a00,b00),a00,b00)
v10prime = 1/dbeta(qbeta(tau,a10,b10),a10,b10)
v01prime = 1/dbeta(qbeta(tau,a01,b01),a01,b01)
plot(tau, log(v10prime+v01prime)-log(v00prime), type = 'l'); abline(h=0, col='red')
}
# A function for visualizing the Beta densities:
dbplot = function(a,b){
tau = seq(from=0,to=1,by=.01)
plot(tau, dbeta(tau,a,b))
}
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 3; a01 = 4; b01 = 1; a00 = 3; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Conditional quantile function of Y[t] given Y[t-1] = 1 and Z[t-1]=0
v10 = function (tau) qbeta(tau, a10,b10)
# Conditional density of Y[t] given Y[t-1] = 1 and Z[t-1]=0
dbplot(a10,b10)
# Conditional quantile function of Y[t] given Y[t-1] = 0 and Z[t-1]=1
v01 = function(tau) qbeta(tau,a01,b01)
# Conditional density of Y[t] given Y[t-1] = 0 and Z[t-1]=1
dbplot(a01,b01)
# Conditional quantile function of Y[t] given Y[t-1] = 0 and Z[t-1]=0
v00 = function(tau) qbeta(tau,a00,b00)
# Conditional density of Y[t] given Y[t-1] = 0 and Z[t-1]=0
dbplot(a00,b00)
# Conditional quantile function of Y[t] given Y[t-1] = 1 and Z[t-1]=1
v11 = function(tau) v10(tau) + v01(tau) - v00(tau)
# Plot of v11 (must be nondecreasing and with range contained in [0,1])
plot(tau.grid, v11(tau.grid))
# Conditional density of Y[t] given Y[t-1] = 1 and Z[t-1]=1
q11 = function(tau) {
1/dbeta(v10(tau),a10,b10) + 1/dbeta(v01(tau),a01,b01) - 1/dbeta(v00(tau),a00,b00)
}
plot(v11(tau.grid), 1/q11(tau.grid), xlim=c(0,1))
# Functional parameters for the quantile regression equation
alpha0 = v00
alpha1 = function(tau) v10(tau) - v00(tau)
theta1 = function(tau) v01(tau) - v00(tau)
# Quantile function of Y given ‚Ñ±[t-1]
Q = function(tau,Y.current,Z.current){
alpha0(tau) + alpha1(tau)*Y.current + theta1(tau)*Z.current
}
# Simulating the sample paths:
# Arbitrary starting point (Y0,Z0)
Y0 = runif(1)
Z0 = runif(1)
Y = Z = numeric()
Z.current = Z0
Y.current = Y0
T = 10001
for (t in 1:T){
# Simulates Y[t] given ‚Ñ±[t-1] using the Fundamental Theorem of Simulation
Y[t] = Q(runif(1), Y.current, Z.current)
Z[t] = Q(runif(1), Z.current, Y.current)
# Q(runif(1), Z.current, Y.current)
# Z[t] = runif(1,max(Y[t]-.01,0),min(Y[t]+.01,1))
Z.current = Z[t]
Y.current = Y[t]
}
acf(Y, lwd=16, lend=3, col='gray')
pacf(Y, lwd=16, lend=3, col='gray')
plot(Y[2:T]~Y[1:(T-1)], pch=16, col=rgb(0,0,0,.4))
plot(Y[2:T]~Z[1:(T-1)], pch=16, col=rgb(0,0,0,.4))
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 10; a01 = 4; b01 = 1; a00 = 3; b00 = 1}
# Conditional quantile function of Y[t] given Y[t-1] = 1 and Z[t-1]=0
v10 = function (tau) qbeta(tau, a10,b10)
# Conditional density of Y[t] given Y[t-1] = 1 and Z[t-1]=0
dbplot(a10,b10)
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 10; a01 = 4; b01 = 1; a00 = 10; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 10; a01 = 6; b01 = 1; a00 = 10; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 10; a01 = 6; b01 = 2; a00 = 10; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 10; a01 = 8; b01 = 1; a00 = 10; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 10; a01 = 10; b01 = 1; a00 = 10; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 10; a01 = 12; b01 = 1; a00 = 10; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 10; a01 = 12; b01 = 2; a00 = 10; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 10; a01 = 12; b01 = 1/2; a00 = 10; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 10; a01 = 24; b01 = 1/2; a00 = 10; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 8; a01 = 24; b01 = 1/2; a00 = 8; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 8; a01 = 12; b01 = 1/2; a00 = 8; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 8; a01 = 12; b01 = 1/4; a00 = 8; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 8; a01 = 7; b01 = 1/4; a00 = 8; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Parameters for the Beta quantile functions v10, v01 and v00
{a10 = 1; b10 = 8; a01 = 7; b01 = 1/2; a00 = 8; b00 = 1}
qdbplot(a10,b10, a01,b01, a00,b00)
# Conditional quantile function of Y[t] given Y[t-1] = 1 and Z[t-1]=0
v10 = function (tau) qbeta(tau, a10,b10)
# Conditional density of Y[t] given Y[t-1] = 1 and Z[t-1]=0
dbplot(a10,b10)
# Conditional quantile function of Y[t] given Y[t-1] = 0 and Z[t-1]=1
v01 = function(tau) qbeta(tau,a01,b01)
# Conditional density of Y[t] given Y[t-1] = 0 and Z[t-1]=1
dbplot(a01,b01)
# Conditional quantile function of Y[t] given Y[t-1] = 0 and Z[t-1]=0
v00 = function(tau) qbeta(tau,a00,b00)
# Conditional density of Y[t] given Y[t-1] = 0 and Z[t-1]=0
dbplot(a00,b00)
# Conditional quantile function of Y[t] given Y[t-1] = 1 and Z[t-1]=1
v11 = function(tau) v10(tau) + v01(tau) - v00(tau)
# Plot of v11 (must be nondecreasing and with range contained in [0,1])
plot(tau.grid, v11(tau.grid))
# Conditional density of Y[t] given Y[t-1] = 1 and Z[t-1]=1
q11 = function(tau) {
1/dbeta(v10(tau),a10,b10) + 1/dbeta(v01(tau),a01,b01) - 1/dbeta(v00(tau),a00,b00)
}
plot(v11(tau.grid), 1/q11(tau.grid), xlim=c(0,1))
# Functional parameters for the quantile regression equation
alpha0 = v00
alpha1 = function(tau) v10(tau) - v00(tau)
theta1 = function(tau) v01(tau) - v00(tau)
# Quantile function of Y given ‚Ñ±[t-1]
Q = function(tau,Y.current,Z.current){
alpha0(tau) + alpha1(tau)*Y.current + theta1(tau)*Z.current
}
# Arbitrary starting point (Y0,Z0)
Y0 = runif(1)
Z0 = runif(1)
Y = Z = numeric()
Z.current = Z0
Y.current = Y0
T = 10001
for (t in 1:T){
# Simulates Y[t] given ‚Ñ±[t-1] using the Fundamental Theorem of Simulation
Y[t] = Q(runif(1), Y.current, Z.current)
Z[t] = Q(runif(1), Z.current, Y.current)
# Q(runif(1), Z.current, Y.current)
# Z[t] = runif(1,max(Y[t]-.01,0),min(Y[t]+.01,1))
Z.current = Z[t]
Y.current = Y[t]
}
acf(Y, lwd=16, lend=3, col='gray')
pacf(Y, lwd=16, lend=3, col='gray')
plot(Y[2:T]~Y[1:(T-1)], pch=16, col=rgb(0,0,0,.4))
plot(Y[2:T]~Z[1:(T-1)], pch=16, col=rgb(0,0,0,.4))
hist(Y, border=NA, breaks="FD")
ts.plot(Y)
# True and estimated functional parameters
Yvec = Y[2:T]
Xmat = cbind(Y[1:(T-1)], Z[1:(T-1)])
qrfit = rq(Yvec~Xmat, tau = tau.grid)
plot(tau.grid, alpha0(tau.grid), type = 'l', col='blue', lwd=2, lty='dotted')
lines(tau.grid, coef(qrfit)[1,], lwd=2, col = rgb(0,0,0,.7))
plot(tau.grid, alpha1(tau.grid), type = 'l', col='blue', lwd=2, lty='dotted')
lines(tau.grid, coef(qrfit)[2,], lwd=2, col = rgb(0,0,0,.7))
plot(tau.grid, theta1(tau.grid), type = 'l', col='blue', lwd=2, lty='dotted')
lines(tau.grid, coef(qrfit)[3,], lwd=2, col = rgb(0,0,0,.7))
conquerfit = sapply(tau.grid, function(tau) conquer(Xmat,Yvec,tau=tau)$coeff)
plot(tau.grid, alpha0(tau.grid), type = 'l', col='blue', lwd=2, lty='dotted')
lines(tau.grid, conquerfit[1,], lwd=2, col = rgb(0,0,0,.7))
plot(tau.grid, alpha1(tau.grid), type = 'l', col='blue', lwd=2, lty='dotted')
lines(tau.grid, conquerfit[2,], lwd=2, col = rgb(0,0,0,.7))
plot(tau.grid, theta1(tau.grid), type = 'l', col='blue', lwd=2, lty='dotted')
lines(tau.grid, conquerfit[3,], lwd=2, col = rgb(0,0,0,.7))
# Conditional density of Y[t] given Y[t-1] = 1 and Z[t-1]=0
dbplot(a10,b10)
# Conditional density of Y[t] given Y[t-1] = 0 and Z[t-1]=1
dbplot(a01,b01)
# Conditional density of Y[t] given Y[t-1] = 0 and Z[t-1]=0
dbplot(a00,b00)
plot(v11(tau.grid), 1/q11(tau.grid), xlim=c(0,1))
# Arbitrary starting point (Y0,Z0)
Y0 = runif(1)
Z0 = runif(1)
Y = Z = numeric()
Z.current = Z0
Y.current = Y0
T = 10001
for (t in 1:T){
# Simulates Y[t] given ‚Ñ±[t-1] using the Fundamental Theorem of Simulation
Y[t] = Q(runif(1), Y.current, Z.current)
Z[t] = runif(1)#Q(runif(1), Z.current, Y.current)
# Q(runif(1), Z.current, Y.current)
# Z[t] = runif(1,max(Y[t]-.01,0),min(Y[t]+.01,1))
Z.current = Z[t]
Y.current = Y[t]
}
acf(Y, lwd=16, lend=3, col='gray')
pacf(Y, lwd=16, lend=3, col='gray')
plot(Y[2:T]~Y[1:(T-1)], pch=16, col=rgb(0,0,0,.4))
plot(Y[2:T]~Z[1:(T-1)], pch=16, col=rgb(0,0,0,.4))
hist(Y, border=NA, breaks="FD")
plot(g(tau.grid))
g = function(z) (atan(z)+pi/2)/pi
plot(g(tau.grid))
plot(tau.grid,g(tau.grid))
plot(tau.grid, tan(tau.grid))
plot(tau.grid, tan(2*tau.grid))
plot(tan(tau.grid-1))
plot(tau.grid, tan(tau.grid))
tau_grid = seq(from=.1, to=.9, by =.05)
tau_grid
library(quantreg)
library(qrcm)
#require(splines)
require(hdrcde)
N = length(maxtemp)
X <- maxtemp[-N] # exclude last observation
Y <- maxtemp[-1] # exclude first observation
s <- (X<40)  #Delete a few (influential, ridiculously hot) days
X <- X[s]
Y <- Y[s]
idx = sort.int(X, index.return = TRUE)$ix # sort sample in acending order (X)
X = X[idx]
Y = Y[idx]
X = X[-1] # this guy seems to be an outlier
Y = Y[-1]
X = log(X) # the scatterplot looks nicer on log scale
Y = log(Y)
dev.off()
plot(Y~X, pch = 16, col=rgb(0,0,1,.2), cex=.5, xlab = "yesterday's max temperature", ylab = "today's max temperature")
Xmat = cbind(X^1,X^2)
fo1o = lm(Y~Xmat)
lines(X, cbind(1,Xmat)%*%fo1o$coef, lwd=4, col=rgb(0,0,0,.2))
tau_grid = seq(from=.1, to=.9, by =.05)
fo2o = rq(Y~Xmat, tau = tau_grid)
### FRUMENTO
fo3o = qrcm::iqr(Y~Xmat, formula.p = ~slp(p,k=3))
fo4o=slp(tau_grid,k=3)
PHI = cbind(1,fo4o)
BETA = fo3o$coef%*%t(PHI)
plot(tau_grid, BETA[1,])
plot(tau_grid, BETA[2,])
plot(tau_grid, BETA[3,])
plot(tau_grid, BETA[4,])
### GLOBAL
source('Utils.R')
phi = generate_phi(3, tau_grid)
phi = phi_generator(3, tau_grid)
plot(tau_grid, phi[,1])
plot(tau_grid, phi[1,])
plot(tau_grid, phi[2,])
plot(tau_grid, phi[3,])
plot(tau_grid, phi[4,])
L = 3
### FRUMENTO
fo3o = qrcm::iqr(Y~Xmat, formula.p = ~slp(p,k=L-1))
fo4o=slp(tau_grid,k=3)
PHI = cbind(1,fo4o)
dim(PHI)
fo4o=slp(tau_grid,k=L-1)
PHI = cbind(1,fo4o)
fo4o=slp(tau_grid,k=L-1)
dim(PHI)
BETA = fo3o$coef%*%t(PHI)
Xpred = cbind(1,Xmat)%*%BETA
phi = phi_generator(L, tau_grid)
dim(phi)
M = length(tau_grid)
D = ncol(Xmat) + 1 # plus 1 for intercept
D
N = nrow(Xmat)
Y = matrix(rep(Y,M),N,M)
TAUS = matrix(rep(taus,N),N,M, byrow = TRUE)
TAUS = matrix(rep(tau_grid,N),N,M, byrow = TRUE)
a = Variable(D,L)
objective = R(a, Y, X, TAUS, phi)
Xmat1 = cbind(1,Xmat)
objective = R(a, Y, Xmat1, TAUS, phi)
problem = Problem(Minimize(objective))
result = solve(problem)
ahat = result$getValue(a)
bhat = ahat%*%phi
dim(bhat)
plot(BETA[1,])
dim(BETA)
plot(BETA[1,])
plot(bhat[1,])
plot(BETA[1,])
points(bhat[1,], pch=16)
plot(bhat[1,])
points(BETA[1,], pch=16)
plot(bhat[1,]/BETA[1,])
plot(bhat[2,])
points(BETA[2,], pch=16)
plot(bhat[3,])
points(BETA[3,], pch=16)
dim(fo2o$coefficients)
points(fo2o$coef[3,], pch=16, col='red')
q()
library(quantreg)
library(qrcm)
#require(splines)
require(hdrcde)
N = length(maxtemp)
X <- maxtemp[-N] # exclude last observation
Y <- maxtemp[-1] # exclude first observation
s <- (X<40)  #Delete a few (influential, ridiculously hot) days
X <- X[s]
Y <- Y[s]
idx = sort.int(X, index.return = TRUE)$ix # sort sample in acending order (X)
X = X[idx]
Y = Y[idx]
X = X[-1] # this guy seems to be an outlier
Y = Y[-1]
X = log(X) # the scatterplot looks nicer on log scale
Y = log(Y)
dev.off()
plot(Y~X, pch = 16, col=rgb(0,0,1,.2), cex=.5, xlab = "yesterday's max temperature", ylab = "today's max temperature")
Xmat = cbind(X^1,X^2)
fo1o = lm(Y~Xmat)
lines(X, cbind(1,Xmat)%*%fo1o$coef, lwd=4, col=rgb(0,0,0,.2))
tau_grid = seq(from=.01, to=.99, by =.01)
fo2o = rq(Y~Xmat, tau = tau_grid)
L = 3
### FRUMENTO
fo3o = qrcm::iqr(Y~Xmat, formula.p = ~slp(p,k=L-1))
fo4o=slp(tau_grid,k=L-1)
PHI = cbind(1,fo4o)
BETA = fo3o$coef%*%t(PHI)
Xpred = cbind(1,Xmat)%*%BETA
### GLOBAL
source('Utils.R')
phi = phi_generator(L, tau_grid)
M = length(tau_grid)
D = ncol(Xmat) + 1 # plus 1 for intercept
N = nrow(Xmat)
Y = matrix(rep(Y,M),N,M)
TAUS = matrix(rep(tau_grid,N),N,M, byrow = TRUE)
a = Variable(D,L)
Xmat1 = cbind(1,Xmat)
objective = R(a, Y, Xmat1, TAUS, phi)
problem = Problem(Minimize(objective))
result = solve(problem)
ahat = result$getValue(a)
bhat = ahat%*%phi
plot(tau_grid, phi[1,])
plot(tau_grid, bhat[1,])
points(tau_grid,BETA[1,], pch=16)
plot(tau_grid, bhat[2,])
points(tau_grid,BETA[2,], pch=16)
plot(tau_grid, bhat[3,])
points(tau_grid,BETA[3,], pch=16)
