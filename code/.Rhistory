v11 = function (tau) v10(tau) + v01(tau) - v00(tau)
plot(tau.grid, v11(tau.grid))
dbplot = function(a,b){
tau = seq(from=0,to=1,by=.01)
plot(tau, dbeta(tau,a,b))
}
# Functional parameters
b0 = v00
b1 = function(tau) v10(tau) - v00(tau)
b2 = function(tau) v11(tau) - v10(tau)
# Quantile function of y[t] given ℱ[t-1]
Q = function(tau,y.current,x.current){
b0(tau) + b1(tau)*y.current + b2(tau)*x.current
}
T = 10000
for (t in 1:T){
# simulates y[t] given ℱ[t-1] using the Fundamental Theorem of Simulation
y[t] = Q(runif(1), y.current, x.current)
# x[t] has the “same” quantile function as y[t]
x[t] = Q(runif(1), x.current, y.current)#runif(1,max(y[t]-.1,0),min(y[t]+.1,1))#Q(runif(1), x.current, y.current)
x.current = x[t]
y.current = y[t]
}
acf(y)
pacf(y)
plot(y[2:T]~y[1:(T-1)])
plot(y[2:T]~x[1:(T-1)])
hist(y, border=NA, breaks="FD")
# v11 = function (tau) qbeta(tau, 2,12)
# v01 = function (tau) v00(tau) + v11(tau) - v10(tau)
v01 = function(tau) qbeta(tau,8,2)
# set.seed(1)
library(quantreg)
library(conquer)
tau.grid = seq(from=.01,to=.99, by=.01)
# Arbitrary starting point (y0,x0)
y0 = runif(1)
x0 = runif(1)
y = x = numeric()
x.current = x0
y.current = y0
# Value of the conditional quantile function at three
# vertices of the unit square
v00 = function(tau) qbeta(tau, 8,2)
v10 = function (tau) qbeta(tau, 2,8)
# v11 = function (tau) qbeta(tau, 2,12)
# v01 = function (tau) v00(tau) + v11(tau) - v10(tau)
v01 = function(tau) qbeta(tau,8,2)
v11 = function (tau) v10(tau) + v01(tau) - v00(tau)
plot(tau.grid, v11(tau.grid))
dbplot(16,2)
dbplot(9,2)
# Value of the conditional quantile function at three
# vertices of the unit square
v00 = function(tau) qbeta(tau, 8,2)
v10 = function (tau) qbeta(tau, 2,8)
# v11 = function (tau) qbeta(tau, 2,12)
# v01 = function (tau) v00(tau) + v11(tau) - v10(tau)
v01 = function(tau) qbeta(tau,8,2)
v11 = function (tau) v10(tau) + v01(tau) - v00(tau)
plot(tau.grid, v11(tau.grid))
dbplot = function(a,b){
tau = seq(from=0,to=1,by=.01)
plot(tau, dbeta(tau,a,b))
}
# Functional parameters
b0 = v00
b1 = function(tau) v10(tau) - v00(tau)
b2 = function(tau) v11(tau) - v10(tau)
# Quantile function of y[t] given ℱ[t-1]
Q = function(tau,y.current,x.current){
b0(tau) + b1(tau)*y.current + b2(tau)*x.current
}
T = 10000
for (t in 1:T){
# simulates y[t] given ℱ[t-1] using the Fundamental Theorem of Simulation
y[t] = Q(runif(1), y.current, x.current)
# x[t] has the “same” quantile function as y[t]
x[t] = runif(1)#Q(runif(1), x.current, y.current)#runif(1,max(y[t]-.1,0),min(y[t]+.1,1))#Q(runif(1), x.current, y.current)
x.current = x[t]
y.current = y[t]
}
acf(y)
pacf(y)
plot(y[2:T]~y[1:(T-1)])
plot(y[2:T]~x[1:(T-1)])
hist(y, border=NA, breaks="FD")
ts.plot(y)
Y = y[2:T]
X = cbind(y[1:(T-1)], x[1:(T-1)])
conquerfit = sapply(tau.grid, function(tau) conquer(X,Y,tau=tau)$coeff)
plot(tau.grid, b0(tau.grid), type = 'l', col='blue', lwd=2, lty='dotted')
lines(tau.grid, conquerfit[1,], lwd=2, col = rgb(0,0,0,.7))
plot(tau.grid, b1(tau.grid), type = 'l', col='blue', lwd=2, lty='dotted')
lines(tau.grid, conquerfit[2,], lwd=2, col = rgb(0,0,0,.7))
plot(tau.grid, b2(tau.grid), type = 'l', col='blue', lwd=2, lty='dotted')
lines(tau.grid, conquerfit[3,], lwd=2, col = rgb(0,0,0,.7))
# Value of the conditional quantile function at three
# vertices of the unit square
v00 = function(tau) qbeta(tau, 8,2)
v10 = function (tau) qbeta(tau, 2,8)
# v11 = function (tau) qbeta(tau, 2,12)
# v01 = function (tau) v00(tau) + v11(tau) - v10(tau)
v01 = function(tau) qbeta(tau,9,2)
v11 = function (tau) v10(tau) + v01(tau) - v00(tau)
plot(tau.grid, v11(tau.grid))
dbplot(9,2)
dbplot(8,2)
dbplot(20,19)
# v11 = function (tau) qbeta(tau, 2,12)
# v01 = function (tau) v00(tau) + v11(tau) - v10(tau)
v01 = function(tau) qbeta(tau,20,19)
v11 = function (tau) v10(tau) + v01(tau) - v00(tau)
plot(tau.grid, v11(tau.grid))
# v11 = function (tau) qbeta(tau, 2,12)
# v01 = function (tau) v00(tau) + v11(tau) - v10(tau)
v01 = function(tau) qbeta(tau,10,2)
v11 = function (tau) v10(tau) + v01(tau) - v00(tau)
plot(tau.grid, v11(tau.grid))
dbplot(10,2)
dbplot(8,2)
dbplot(8,3)
# v11 = function (tau) qbeta(tau, 2,12)
# v01 = function (tau) v00(tau) + v11(tau) - v10(tau)
v01 = function(tau) qbeta(tau,8,3)
v11 = function (tau) v10(tau) + v01(tau) - v00(tau)
plot(tau.grid, v11(tau.grid))
dbplot = function(a,b){
tau = seq(from=0,to=1,by=.01)
plot(tau, dbeta(tau,a,b))
}
# Functional parameters
b0 = v00
b1 = function(tau) v10(tau) - v00(tau)
b2 = function(tau) v11(tau) - v10(tau)
# Quantile function of y[t] given ℱ[t-1]
Q = function(tau,y.current,x.current){
b0(tau) + b1(tau)*y.current + b2(tau)*x.current
}
T = 10000
for (t in 1:T){
# simulates y[t] given ℱ[t-1] using the Fundamental Theorem of Simulation
y[t] = Q(runif(1), y.current, x.current)
# x[t] has the “same” quantile function as y[t]
x[t] = runif(1)#Q(runif(1), x.current, y.current)#runif(1,max(y[t]-.1,0),min(y[t]+.1,1))#Q(runif(1), x.current, y.current)
x.current = x[t]
y.current = y[t]
}
acf(y)
pacf(y)
plot(y[2:T]~y[1:(T-1)])
plot(y[2:T]~x[1:(T-1)])
hist(y, border=NA, breaks="FD")
ts.plot(y)
Y = y[2:T]
X = cbind(y[1:(T-1)], x[1:(T-1)])
conquerfit = sapply(tau.grid, function(tau) conquer(X,Y,tau=tau)$coeff)
plot(tau.grid, b0(tau.grid), type = 'l', col='blue', lwd=2, lty='dotted')
lines(tau.grid, conquerfit[1,], lwd=2, col = rgb(0,0,0,.7))
plot(tau.grid, b1(tau.grid), type = 'l', col='blue', lwd=2, lty='dotted')
lines(tau.grid, conquerfit[2,], lwd=2, col = rgb(0,0,0,.7))
plot(tau.grid, b2(tau.grid), type = 'l', col='blue', lwd=2, lty='dotted')
lines(tau.grid, conquerfit[3,], lwd=2, col = rgb(0,0,0,.7))
dbplot(8,3)
dbplot(8,4)
# v11 = function (tau) qbeta(tau, 2,12)
# v01 = function (tau) v00(tau) + v11(tau) - v10(tau)
v01 = function(tau) qbeta(tau,8,4)
v11 = function (tau) v10(tau) + v01(tau) - v00(tau)
plot(tau.grid, v11(tau.grid))
# v11 = function (tau) qbeta(tau, 2,12)
# v01 = function (tau) v00(tau) + v11(tau) - v10(tau)
v01 = function(tau) qbeta(tau,7,4)
v11 = function (tau) v10(tau) + v01(tau) - v00(tau)
plot(tau.grid, v11(tau.grid))
# v11 = function (tau) qbeta(tau, 2,12)
# v01 = function (tau) v00(tau) + v11(tau) - v10(tau)
v01 = function(tau) qbeta(tau,6,4)
v11 = function (tau) v10(tau) + v01(tau) - v00(tau)
plot(tau.grid, v11(tau.grid))
# v11 = function (tau) qbeta(tau, 2,12)
# v01 = function (tau) v00(tau) + v11(tau) - v10(tau)
v01 = function(tau) qbeta(tau,8,3)
v11 = function (tau) v10(tau) + v01(tau) - v00(tau)
plot(tau.grid, v11(tau.grid))
dbplot = function(a,b){
tau = seq(from=0,to=1,by=.01)
plot(tau, dbeta(tau,a,b))
}
# Functional parameters
b0 = v00
b1 = function(tau) v10(tau) - v00(tau)
b2 = function(tau) v11(tau) - v10(tau)
# Quantile function of y[t] given ℱ[t-1]
Q = function(tau,y.current,x.current){
b0(tau) + b1(tau)*y.current + b2(tau)*x.current
}
T = 10000
for (t in 1:T){
# simulates y[t] given ℱ[t-1] using the Fundamental Theorem of Simulation
y[t] = Q(runif(1), y.current, x.current)
# x[t] has the “same” quantile function as y[t]
x[t] = runif(1)#Q(runif(1), x.current, y.current)#runif(1,max(y[t]-.1,0),min(y[t]+.1,1))#Q(runif(1), x.current, y.current)
x.current = x[t]
y.current = y[t]
}
acf(y)
pacf(y)
plot(y[2:T]~y[1:(T-1)])
plot(y[2:T]~x[1:(T-1)])
hist(y, border=NA, breaks="FD")
ts.plot(y)
Y = y[2:T]
X = cbind(y[1:(T-1)], x[1:(T-1)])
# set.seed(1)
library(quantreg)
library(conquer)
tau.grid = seq(from=.01,to=.99, by=.01)
# Arbitrary starting point (y0,x0)
y0 = runif(1)
x0 = runif(1)
y = x = numeric()
x.current = x0
y.current = y0
# Value of the conditional quantile function at three
# vertices of the unit square
v00 = function(tau) qbeta(tau, 8,2)
v10 = function (tau) qbeta(tau, 2,8)
# v11 = function (tau) qbeta(tau, 2,12)
# v01 = function (tau) v00(tau) + v11(tau) - v10(tau)
v01 = function(tau) qbeta(tau,8,2)
v11 = function (tau) v10(tau) + v01(tau) - v00(tau)
plot(tau.grid, v11(tau.grid))
# Value of the conditional quantile function at three
# vertices of the unit square
v00 = function(tau) qbeta(tau, 8,2)
dbplot(8,2)
dbplot = function(a,b){
tau = seq(from=0,to=1,by=.01)
plot(tau, dbeta(tau,a,b))
}
dbplot(8,2)
dbplot(2,8)
dbplot(8,2)
# Functional parameters
b0 = v00
b1 = function(tau) v10(tau) - v00(tau)
b2 = function(tau) v11(tau) - v10(tau)
# Quantile function of y[t] given ℱ[t-1]
Q = function(tau,y.current,x.current){
b0(tau) + b1(tau)*y.current + b2(tau)*x.current
}
T = 10000
for (t in 1:T){
# simulates y[t] given ℱ[t-1] using the Fundamental Theorem of Simulation
y[t] = Q(runif(1), y.current, x.current)
# x[t] has the “same” quantile function as y[t]
x[t] = runif(1)#Q(runif(1), x.current, y.current)#runif(1,max(y[t]-.1,0),min(y[t]+.1,1))#Q(runif(1), x.current, y.current)
x.current = x[t]
y.current = y[t]
}
acf(y)
pacf(y)
plot(y[2:T]~y[1:(T-1)])
lm(y[2:T]~y[1:(T-1)])
abline(lm(y[2:T]~y[1:(T-1)]),col='red')
plot(y[2:T]~x[1:(T-1)])
# Arbitrary starting point (y0,x0)
y0 = runif(1)
x0 = runif(1)
y = x = numeric()
x.current = x0
y.current = y0
# Value of the conditional quantile function at three
# vertices of the unit square
v00 = function(tau) qbeta(tau, 8,2)
v10 = function (tau) qbeta(tau, 2,8)
# v11 = function (tau) qbeta(tau, 2,12)
# v01 = function (tau) v00(tau) + v11(tau) - v10(tau)
v01 = function(tau) qbeta(tau,8,2)
v11 = function (tau) v10(tau) + v01(tau) - v00(tau)
plot(tau.grid, v11(tau.grid))
dbplot = function(a,b){
tau = seq(from=0,to=1,by=.01)
plot(tau, dbeta(tau,a,b))
}
# Functional parameters
b0 = v00
b1 = function(tau) v10(tau) - v00(tau)
b2 = function(tau) v11(tau) - v10(tau)
# Quantile function of y[t] given ℱ[t-1]
Q = function(tau,y.current,x.current){
b0(tau) + b1(tau)*y.current + b2(tau)*x.current
}
T = 10000
for (t in 1:T){
# simulates y[t] given ℱ[t-1] using the Fundamental Theorem of Simulation
y[t] = Q(runif(1), y.current, x.current)
#x[t] = runif(1)
#Q(runif(1), x.current, y.current)
x[t] = runif(1,max(y[t]-.2,0),min(y[t]+.2,1))
#Q(runif(1), x.current, y.current)
x.current = x[t]
y.current = y[t]
}
acf(y)
pacf(y)
plot(y[2:T]~y[1:(T-1)])
plot(y[2:T]~x[1:(T-1)])
plot(y~x)
plot(y,x)
T = 10000
for (t in 1:T){
# simulates y[t] given ℱ[t-1] using the Fundamental Theorem of Simulation
y[t] = Q(runif(1), y.current, x.current)
#x[t] = runif(1)
#Q(runif(1), x.current, y.current)
x[t] = runif(1,max(y[t]-.01,0),min(y[t]+.01,1))
#Q(runif(1), x.current, y.current)
x.current = x[t]
y.current = y[t]
}
acf(y)
pacf(y)
plot(y[2:T]~y[1:(T-1)])
plot(y[2:T]~x[1:(T-1)])
plot(y,x)
hist(y, border=NA, breaks="FD")
ts.plot(y)
hist(y, border=NA, breaks="FD")
Y = y[2:T]
X = cbind(y[1:(T-1)], x[1:(T-1)])
conquerfit = sapply(tau.grid, function(tau) conquer(X,Y,tau=tau)$coeff)
plot(tau.grid, b0(tau.grid), type = 'l', col='blue', lwd=2, lty='dotted')
lines(tau.grid, conquerfit[1,], lwd=2, col = rgb(0,0,0,.7))
plot(tau.grid, b1(tau.grid), type = 'l', col='blue', lwd=2, lty='dotted')
lines(tau.grid, conquerfit[2,], lwd=2, col = rgb(0,0,0,.7))
plot(tau.grid, b0(tau.grid), type = 'l', col='blue', lwd=2, lty='dotted')
lines(tau.grid, conquerfit[1,], lwd=2, col = rgb(0,0,0,.7))
plot(tau.grid, b1(tau.grid), type = 'l', col='blue', lwd=2, lty='dotted')
lines(tau.grid, conquerfit[2,], lwd=2, col = rgb(0,0,0,.7))
plot(tau.grid, b2(tau.grid), type = 'l', col='blue', lwd=2, lty='dotted')
lines(tau.grid, conquerfit[3,], lwd=2, col = rgb(0,0,0,.7))
# set.seed(1)
library(quantreg)
library(conquer)
tau.grid = seq(from=.01,to=.99, by=.01)
# Arbitrary starting point (y0,x0)
y0 = runif(1)
x0 = runif(1)
y = x = numeric()
x.current = x0
y.current = y0
# Value of the conditional quantile function at three
# vertices of the unit square
v00 = function(tau) qbeta(tau, 8,2)
v10 = function (tau) qbeta(tau, 2,8)
# v11 = function (tau) qbeta(tau, 2,12)
# v01 = function (tau) v00(tau) + v11(tau) - v10(tau)
v01 = function(tau) qbeta(tau,9,2)
v11 = function (tau) v10(tau) + v01(tau) - v00(tau)
plot(tau.grid, v11(tau.grid))
dbplot = function(a,b){
tau = seq(from=0,to=1,by=.01)
plot(tau, dbeta(tau,a,b))
}
# Functional parameters
b0 = v00
b1 = function(tau) v10(tau) - v00(tau)
b2 = function(tau) v11(tau) - v10(tau)
# Quantile function of y[t] given ℱ[t-1]
Q = function(tau,y.current,x.current){
b0(tau) + b1(tau)*y.current + b2(tau)*x.current
}
T = 10000
for (t in 1:T){
# simulates y[t] given ℱ[t-1] using the Fundamental Theorem of Simulation
y[t] = Q(runif(1), y.current, x.current)
x[t] = runif(1)
# Q(runif(1), x.current, y.current)
# x[t] = runif(1,max(y[t]-.01,0),min(y[t]+.01,1))
# Q(runif(1), x.current, y.current)
x.current = x[t]
y.current = y[t]
}
acf(y)
pacf(y)
plot(y[2:T]~y[1:(T-1)])
plot(y[2:T]~x[1:(T-1)])
hist(y, border=NA, breaks="FD")
ts.plot(y)
Y = y[2:T]
X = cbind(y[1:(T-1)], x[1:(T-1)])
conquerfit = sapply(tau.grid, function(tau) conquer(X,Y,tau=tau)$coeff)
plot(tau.grid, b0(tau.grid), type = 'l', col='blue', lwd=2, lty='dotted')
lines(tau.grid, conquerfit[1,], lwd=2, col = rgb(0,0,0,.7))
plot(tau.grid, b1(tau.grid), type = 'l', col='blue', lwd=2, lty='dotted')
lines(tau.grid, conquerfit[2,], lwd=2, col = rgb(0,0,0,.7))
plot(tau.grid, b2(tau.grid), type = 'l', col='blue', lwd=2, lty='dotted')
lines(tau.grid, conquerfit[3,], lwd=2, col = rgb(0,0,0,.7))
plot(tau.grid, b2(tau.grid), type = 'l', col='blue', lwd=2, lty='dotted')
# Value of the conditional quantile function at three
# vertices of the unit square
v00 = function(tau) qbeta(tau, 8,2)
v10 = function (tau) qbeta(tau, 2,8)
# v11 = function (tau) qbeta(tau, 2,12)
# v01 = function (tau) v00(tau) + v11(tau) - v10(tau)
v01 = function(tau) qbeta(tau,9,9)
v11 = function (tau) v10(tau) + v01(tau) - v00(tau)
plot(tau.grid, v11(tau.grid))
library(quantreg)
#require(splines)
require(hdrcde)
source('sqr_function.r')
x <- maxtemp[-3650]
y <- maxtemp[-1]
plot.ts(maxtemp)
s <- (x<40)  #Delete a few (influential, ridiculously hot) days
x <- x[s]
y <- y[s]
idx = sort.int(x, index.return = TRUE)$ix
x = x[idx]
y = y[idx]
x1 = x
x2 = x^2
x3 = x^3
x4 = x^4
plot(y~x, pch = 16, col=rgb(0,0,0,.2), cex=.5, xlab = "yesterday's max temperature", ylab = "today's max temperature")
abline(lm(y~x), lwd=2)
tau_grid = seq(from=.1, to=.9, by =.1)
for (i in 1:length(tau_grid)){
foo = rq(y~x1+x2+x3+x4, tau = tau_grid[i])
lines(x, foo$fitted.values, col='red')
foo = sqr(x = cbind(rep(1,length(x)), x1, x2, x3, x4), y = y, tau = tau_grid[i], h = 'rule-of-thumb', initial_value = foo$coef)
sqr_fitted = foo[1] + foo[2]*x1 + foo[3]*x2 + foo[4]*x3 + foo[5]*x4
lines(x, sqr_fitted, col='blue')
}
library(quantreg)
library(qrcm)
#require(splines)
require(hdrcde)
N = length(maxtemp)
X <- maxtemp[-N] # exclude last observation
Y <- maxtemp[-1] # exclude first observation
s <- (X<40)  #Delete a few (influential, ridiculously hot) days
X <- X[s]
Y <- Y[s]
idx = sort.int(X, index.return = TRUE)$ix # sort sample in acending order (X)
X = X[idx]
Y = Y[idx]
X = X[-1] # this guy seems to be an outlier
Y = Y[-1]
X = log(X) # the scatterplot looks nicer on log scale
Y = log(Y)
dev.off()
plot(Y~X, pch = 16, col=rgb(0,0,1,.2), cex=.5, xlab = "yesterday's max temperature", ylab = "today's max temperature")
Xmat = cbind(X^1,X^2)
fo1o = lm(Y~Xmat)
lines(X, cbind(1,Xmat)%*%fo1o$coef, lwd=4, col=rgb(0,0,0,.2))
tau_grid = seq(from=.01, to=.99, by =.04)
fo2o = rq(Y~Xmat, tau = tau_grid)
fo3o = qrcm::iqr(Y~Xmat, formula.p = ~slp(p,k=3))
fo4o=slp(tau_grid,k=3)
PHI = cbind(1,fo4o)
BETA = fo3o$coef%*%t(PHI)
Xpred = cbind(1,Xmat)%*%BETA
par(mar=c(0,0,0,0), oma=c(0,0,0,0))
plot(Y~X, ann=FALSE, bty='n', type='n', axes=FALSE)
for (i in 1:length(tau_grid)){
#lines(X, fo2o$fitted.values[,i], col=rgb(1,0,0,.2))
lines(X, Xpred[,i],col=rgb(0,0,0,.2), lwd=1)
}
set.seed(2)
idx = sample(1:N, size = 700, replace = FALSE)
points(Y[idx]~X[idx], pch = 16, col=rgb(0,0,.8,.2), lwd=3, cex=1.2, ann=FALSE, bty='n')
x
head(x)
head(x)^1:3
head(x)^(1:3)
head(x)
sapply(1:4, function(k) head(x)^k)
Xmat = sapply(1:20, function(k) X^k)
fo1o = lm(Y~Xmat)
lines(X, cbind(1,Xmat)%*%fo1o$coef, lwd=4, col=rgb(0,0,0,.2))
plot(Y~X, pch = 16, col=rgb(0,0,1,.2), cex=.5, xlab = "yesterday's max temperature", ylab = "today's max temperature")
lines(X, cbind(1,Xmat)%*%fo1o$coef, lwd=4, col=rgb(0,0,0,.2))
Xmat = sapply(1:20, function(k) X^k)
fo1o = lm(Y~Xmat)
fo1o
Xmat = sapply(1:10, function(k) X^k)
fo1o = lm(Y~Xmat)
fo1o
View(fo1o)
Xmat = cbind(X^1,X^2)
fo1o = lm(Y~Xmat)
lines(X, cbind(1,Xmat)%*%fo1o$coef, lwd=4, col=rgb(0,0,0,.2))
tau_grid = seq(from=.01, to=.99, by =.04)
fo2o = rq(Y~Xmat, tau = tau_grid)
fo3o = qrcm::iqr(Y~Xmat, formula.p = ~slp(p,k=3))
fo4o=slp(tau_grid,k=3)
PHI = cbind(1,fo4o)
BETA = fo3o$coef%*%t(PHI)
Xpred = cbind(1,Xmat)%*%BETA
par(mar=c(0,0,0,0), oma=c(0,0,0,0))
plot(Y~X, ann=FALSE, bty='n', type='n', axes=FALSE)
for (i in 1:length(tau_grid)){
#lines(X, fo2o$fitted.values[,i], col=rgb(1,0,0,.2))
lines(X, Xpred[,i],col=rgb(0,0,0,.2), lwd=1)
}
set.seed(2)
idx = sample(1:N, size = 700, replace = FALSE)
points(Y[idx]~X[idx], pch = 16, col=rgb(0,0,.8,.2), lwd=3, cex=1.2, ann=FALSE, bty='n')
